-- automatically generated by BNF Converter
module Main where


import System.Environment (getArgs)
import System.Exit (exitFailure)

import BNFC.LexLatte
import BNFC.ParLatte
import BNFC.AbsLatte
import BNFC.ErrM

import Types.Typechecker
import CodeGen.CodeGen (codeGen, interpQuad)
import Utils
type ParseFun a = [Token] -> Err a

runFile :: ParseFun Program -> FilePath -> IO ()
runFile p f = readFile f >>= run p

run :: ParseFun Program -> String -> IO ()
run p s = let ts = myLexer s in case p ts of
           Bad err -> do
             putErrLn "ERROR"
             putErrLn "\nParse Failed...\n"
             putErrLn err
             exitFailure
           Ok program -> case typeCheck program of
             Right clsMap -> do
               putErrLn "OK"
               --interpQuad clsMap tree
               putStrLn $ codeGen clsMap program
             Left err ->  do
               putErrLn $ "ERROR\n" ++ err
               exitFailure



usage :: IO ()
usage = do
  putStrLn $ unlines
    [ "usage: Call with one of the following argument combinations:"
    , "  --help          Display this help message."
    , "  (no arguments)  Parse stdin verbosely."
    , "  (files)         Parse content of files verbosely."
    , "  -s (files)      Silent mode. Parse content of files silently."
    ]
  exitFailure

main :: IO ()
main = do
  args <- getArgs
  case args of
    ["--help"] -> usage
    "-s":fs -> mapM_ (runFile pProgram) fs
    fs -> mapM_ (runFile pProgram) fs

